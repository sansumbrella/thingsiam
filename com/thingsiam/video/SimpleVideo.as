package com.thingsiam.video {		/**	*	@author: David Wicks		*	@since: 15.04.2008	*		*	Wraps video connectivity stuff so all you need to do is:	*		*	video.connect();	*	video.play("awesomevideo.mov"); //or .flv	*		*	video.pause();	*		*		*	There's a lot of stuff in here so we can treat streaming video like progressive video.	*	I'll try to clean that up so it's easy to find the stuff you need.	*		*	I also need to standardize on either implicit get() functions or getAttribute() functions	*		*/		import com.thingsiam.math.Numbers;		import flash.display.Sprite;	import flash.events.*;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.Timer;		public class SimpleVideo extends Sprite {		// Events named after NetStatusEvents		public static const META_DATA		:String = "metaDataRead";		public static const NOT_FOUND		:String = "videoNotFound";		public static const CONNECTED		:String = "nsConnected";		public static const FAILED			:String	= "connectionFailed";		public static const PAUSE			:String = "videoPause";		public static const PLAY			:String = "videoPlay";		public static const PROGRESS_UPDATE	:String = "videoProgress";		public static const LOAD_UPDATE	:String = "vidLoading";		public static const NC_TIMEOUT		:String = "ncTimeout";		public static const INSUFFICIENT_BANDWIDTH:String = "insufficientBandwidth";				// Replacement events fired when you would expect them to		public static const PLAYBACK_INIT	:String = "playbackInit";	//fired the first time the buffer is full		public static const END				:String = "videoEnd";		//fired when ns.time >= ns.duration - tolerance		private const END_TIME_TOLERANCE	:Number = 0.1;				//because you can never trust NetStreams		private var _firstBuffer:Boolean = true				// Connection strings		private var _port:String="any",		_protocol:String="any";		private var _connections:Array;	//houses all our NetConnectionWrappers		private var _connectionAttempt:int;		private var _NC:Array;		private var _streamEstablished:Boolean = false;		private var _connectionEstablished:Boolean = false;		private var _ip:String;		private var _appName:String;		private var _authParams:String = "";		private var _hostName:String;		private var _server:String;		private var _akLoader:URLLoader;	//for loading XML from Akamai		private var isLive:Boolean = false;				// Timers for spacing streaming connection attempts (and giving up)		private const TIMEOUT:uint = 15000;		private const REQUEST_STAGGERING:uint = 220;		private var _timeoutTimer:Timer;		private var _connectionTimer:Timer;				//bufferTime for NetStream in seconds (should be longer for streaming connections)		private var _bufferTime:Number = 0.2;		private var PROGRESSIVE_BUFFER_TIME:Number = 0.2;		private var STREAMING_BUFFER_PLAYING:Number = 30.0;		private var STREAMING_BUFFER_INIT:Number = 2.0;				private var _player:Video;		private var	_nc:NetConnection;		private var	_ns:NetStream;		private var	_ratio:Number = 16/9; //will get reset by metadata		private var	localClient:Object;		private var	_duration:Number = 0;		private var	_pVolume:Number = 1;	//stores volume to jump back to when unmuting		private var	_url:String;		private var	_playbackTimer:Timer; private const PLAYBACK_INTERVAL:Number=20;//to trigger complete event properly		private var	_loadTimer:Timer;		private var	_isPaused:Boolean = true;		private var	_w:Number, _h:Number;		private var _isSeeking:Boolean = false;		private var _seekTarget:Number;		public function SimpleVideo(w:Number = 640, h:Number = 480 ) {						this._player = new Video( w, h );			this._w = w;			this._h = h;						initTimers();		}				public function connect( server:String=null ):void {						if( _server != null && server == _server && _nc && _nc.connected )			{	//we're still connected to the requested server				dispatchEvent( new Event( CONNECTED ) );				return;			}						close();						if( server == null )			{	//easy route				setupProgressiveConnection();			} else			{	//try a lot of connection methods for the streaming				_hostName = server.indexOf("/") != -1 ? server.slice(0,server.indexOf("/")):server;				_appName = server.indexOf("/") != -1 && server.indexOf("/") != server.length-1 ? server.slice(server.indexOf("/")+1):isLive ? "live":"ondemand";				_connectionEstablished = false;				_streamEstablished = false;								//I believe this is specific to Akamai				//if it fails, we'll still proceed as usual				_akLoader = new URLLoader;				_akLoader.addEventListener( Event.COMPLETE, handleAkamaiXMLLoaded, false, 0, true );				_akLoader.addEventListener( IOErrorEvent.IO_ERROR, handleAkamaiXMLError, false, 0, true );				_akLoader.load( new URLRequest( "http://" + _hostName + "/fcs/ident"));				buildConnectionSequence();			}			_server = server;		}				private function handleAkamaiXMLLoaded( e:Event ):void		{			_ip = XML(_akLoader.data).ip; //probably an Akamai optimization thing			buildConnectionSequence();		}				private function handleAkamaiXMLError( e:Event ):void		{			_ip = _hostName;			buildConnectionSequence();		}				private function setupProgressiveConnection():void		{			_bufferTime = PROGRESSIVE_BUFFER_TIME;			_nc = new NetConnection();			_nc.client = this;			_nc.connect(null);			attachNetStream();		}				public function set bufferTime(value:Number):void {			_bufferTime = PROGRESSIVE_BUFFER_TIME = STREAMING_BUFFER_PLAYING = value;			if( _ns ) _ns.bufferTime = _bufferTime;		}				private function initTimers():void		{			// Events fired during playback			_playbackTimer = new Timer( PLAYBACK_INTERVAL );			_playbackTimer.addEventListener( TimerEvent.TIMER, handlePlaybackTimer );						// Dispatch regular load progress for progressive video, need to add a stopping point			_loadTimer = new Timer( 50 );			_loadTimer.addEventListener( TimerEvent.TIMER, onLoadTimer );						// Master connection timeout			_timeoutTimer = new Timer(TIMEOUT, 1);			_timeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, handleMasterTimeout );			// Controls the delay between each connection attempt			_connectionTimer = new Timer(200);			_connectionTimer.addEventListener(TimerEvent.TIMER, attemptStreamingConnection);					}				private function buildConnectionSequence():void		{			_bufferTime = STREAMING_BUFFER_INIT;			var portProtocols:Array = buildPortProtocolSequence();			_connections = new Array();			for each( var connection:NetConnectionWrapper in _NC )			{				shutdownConnection( connection );			}			_NC = new Array();			for( var i:uint=0; i < portProtocols.length; i++ )			{				var connectionObject:Object = new Object();				var address:String = portProtocols[i].protocol + "://" + _ip + ":" + portProtocols[i].port + "/" + _appName + "?_fcs_vhost=" + _hostName + (_authParams == "" ? "": "&"+_authParams);				connectionObject.address = address;				connectionObject.port = portProtocols[i].port;				connectionObject.protocol = portProtocols[i].protocol;				_connections.push(connectionObject);			}						_timeoutTimer.reset();			_timeoutTimer.start();			_connectionAttempt = 0;			_connectionTimer.reset();			_connectionTimer.delay = REQUEST_STAGGERING;			_connectionTimer.start();			attemptStreamingConnection(null);		}				private function attemptStreamingConnection( e:TimerEvent ):void		{			_NC[_connectionAttempt] = new NetConnectionWrapper();			_NC[_connectionAttempt].addEventListener( NetStatusEvent.NET_STATUS, handleConnectionNetStatus, false, 0, true );			_NC[_connectionAttempt].addEventListener( IOErrorEvent.IO_ERROR, handleError, false, 0, true );			_NC[_connectionAttempt].addEventListener( AsyncErrorEvent.ASYNC_ERROR, handleError, false, 0, true );			_NC[_connectionAttempt].addEventListener( SecurityErrorEvent.SECURITY_ERROR, handleError, false, 0, true );			_NC[_connectionAttempt].client = _NC[_connectionAttempt];			_NC[_connectionAttempt].index = _connectionAttempt;			_NC[_connectionAttempt].expectBWDone = false;			_NC[_connectionAttempt].port = _connections[_connectionAttempt].port;			_NC[_connectionAttempt].protocol = _connections[_connectionAttempt].protocol;			_NC[_connectionAttempt].controller = this;			try			{				_NC[_connectionAttempt].connect( _connections[_connectionAttempt].address, false );			}			catch( err:Error )			{				trace("SimpleVideo::attemptStreamingConnection()", err);			}			finally			{				_connectionAttempt++;				if( _connectionAttempt >= _connections.length )				{					_connectionTimer.stop();				}			}		}				private function buildPortProtocolSequence():Array {			var aTemp:Array = new Array();			if (_port == "any" && _protocol == "any") {				aTemp = [{port:"1935",protocol:"rtmp"},						 {port:"443",protocol:"rtmp"},						 {port:"80",protocol:"rtmp"},						 {port:"80",protocol:"rtmpt"},						 {port:"443",protocol:"rtmpt"},						 {port:"1935",protocol:"rtmpt"},						 {port:"1935",protocol:"rtmpe"},						 {port:"443",protocol:"rtmpe"},						 {port:"80",protocol:"rtmpe"},						 {port:"80",protocol:"rtmpte"},						 {port:"443",protocol:"rtmpte"},						 {port:"1935",protocol:"rtmpte"}];			} else {				if (_port=="any") {					_port = "1935,443,80";				}				if (_protocol=="any") {					_protocol= "rtmp,rtmpt,rtmpe,rtmpte";				}				var aPort:Array = _port.split(",");				var aProtocol:Array = _protocol.split(",");				for (var pr:Number =0; pr < aProtocol.length;pr++) {					for (var po:Number =0; po < aPort.length;po++) {						aTemp.push({port:aPort[po], protocol:aProtocol[pr]});					}				}			}			return aTemp;		}				private function handleMasterTimeout( e:Event ):void		{			for( var i:uint=0; i != _NC.length; i++ )			{				_NC[i].close();				_NC[i] = null;			}			dispatchEvent( new Event( NC_TIMEOUT ) );		}				private function handleRejection( e:NetStatusEvent ):void		{			trace("SimpleVideo::handleRejection()", e);		}				private function handleError( err:Event ):void		{			trace("SimpleVideo::handleError()", err );		}				public function onBWDone():void		{			trace("SimpleVideo::onBWDone()");		}				private function attachNetStream():void		{			if( _ns )			{				_ns.close();				_ns.removeEventListener( AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler );				_ns.removeEventListener( NetStatusEvent.NET_STATUS, handleStreamNetStatus );				_ns.removeEventListener( IOErrorEvent.IO_ERROR, nsIOErrorHandler );			}			_ns = new NetStream( _nc );			_ns.bufferTime = _bufferTime;			localClient = new Object();			localClient.onMetaData = metaDataHandler;			_ns.client = localClient;			_ns.addEventListener( AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler, false, 0, true );			_ns.addEventListener( NetStatusEvent.NET_STATUS, handleStreamNetStatus, false, 0, true );			_ns.addEventListener( IOErrorEvent.IO_ERROR, nsIOErrorHandler, false, 0, true );			_streamEstablished = true;						addChild( _player );			_loadTimer.start();			if( _url ) play( _url );		}				private function handleConnectionNetStatus( e:NetStatusEvent ):void		{	//events from the netConnection object			if( _connectionEstablished )			{				trace("SimpleVideo::handleConnectionNetStatus()", NetConnectionWrapper(e.target).index, e.info.code );				//dispatchEvent( e );			}						switch( e.info.code )			{				case "NetConnection.Connect.Rejected":					handleRejection( e );					break;				case "NetConnection.Connect.Failed":					if( _nc == NetConnectionWrapper( _NC[e.target.index] ) )					{						dispatchEvent( new Event( FAILED ) );						//attempt to reconnect?					}					shutdownConnection( _NC[e.target.index] );					_NC[e.target.index] = null;					break;				case "NetConnection.Connect.Success":					trace("SimpleVideo::handleConnectionNetStatus()", e.info.code );					_timeoutTimer.stop();					_connectionTimer.stop();					for( var i:uint = 0; i < _NC.length; i++ )					{						if( i != e.target.index )						{							shutdownConnection( _NC[i] );							_NC[i] = null;						}					}					_nc = NetConnectionWrapper( e.target );					_connectionEstablished = true;					attachNetStream();					dispatchEvent( new Event( CONNECTED ) );					break;				default:					//trace("SimpleVideo::handleConnectionNetStatus()", e.info.code, e.target.index );					break;			}		}				private function shutdownConnection( connection:NetConnectionWrapper ):void		{			if( connection )			{				connection.close();				connection.removeEventListener( NetStatusEvent.NET_STATUS, handleConnectionNetStatus );				connection.removeEventListener( IOErrorEvent.IO_ERROR, handleError );				connection.removeEventListener( AsyncErrorEvent.ASYNC_ERROR, handleError );				connection.removeEventListener( SecurityErrorEvent.SECURITY_ERROR, handleError );			}		}				private function handleStreamNetStatus( e:NetStatusEvent ):void		{	//events from the netstream object//			trace("SimpleVideo::handleStreamNetStatus()", e.info.code );			switch(e.info.code){				case "NetStream.Play.Start":					// Dispatched by streaming video on scrub, even when paused (does not unpause)					if( !_isPaused ) dispatchEvent( new Event( PLAY ) );										_ns.bufferTime = STREAMING_BUFFER_INIT;				break;				case "NetStream.Buffer.Full":					if( _firstBuffer )					{						_firstBuffer = false;						dispatchEvent( new Event( PLAYBACK_INIT ));					}					if( streaming ) _ns.bufferTime = STREAMING_BUFFER_PLAYING;				break;				case "NetStream.Buffer.Empty":					if( streaming ) _ns.bufferTime = STREAMING_BUFFER_INIT;				break;				case "NetStream.Buffer.Flush":				break;				case "NetStream.Play.Stop":				/*	This event is pretty worthless, as it rarely fires at the actual end of the stream 					Instead of relying on it, the playbackTimer fires a complete event when the video is actually at the end*/				break;				case "NetStream.Play.StreamNotFound" :					dispatchEvent( new Event( NOT_FOUND ) );				break;				case "NetStream.Play.InsufficientBW":					dispatchEvent( new Event( INSUFFICIENT_BANDWIDTH ) );				break;				case "NetStream.Seek.Notify":					if( streaming ) _ns.bufferTime = STREAMING_BUFFER_INIT;/*					if( isPaused )					{						ns.resume();						ns.pause();					}*/				break;				case "NetStream.Pause.Notify": //only sent by streaming connections					_isPaused = true;				break;				case "NetStream.Unpause.Notify": //only sent by streaming connections					_isPaused = false;				break;				default:					if( e.info.level == "error" )					{						trace( e.info.code );					}					break;			}		}		private function handlePlaybackTimer( e:TimerEvent ) : void {			//announce where we are or where we want to be			dispatchEvent( new DataEvent( PROGRESS_UPDATE, false, false, String(progress) ) );			if( _isSeeking == true )			{				if( Math.abs( progress*duration - _seekTarget*duration ) <= 0.5 )				{					_isSeeking = false;				}			}			if( complete() ){				handleComplete();			}		}				private function handleComplete( e:Event = null ) : void {			//prevent multiple firings of complete event (in case we can't pause/seek as fast as the timer)			_playbackTimer.reset();			_ns.pause();			rewind();			dispatchEvent( new Event( END ) );		}				private function onLoadTimer( e:TimerEvent ) : void {			dispatchEvent( new DataEvent( LOAD_UPDATE, false, false, String(getLoadProgress()) ) );		}		public function play( _url:String = null ) : Boolean {			if( _url ) this._url = _url;						if( _ns )			{				_isPaused = false;				_isSeeking = false;				_firstBuffer = true;				_ns.close();				_player.clear();				_ns.play(_url);				_player.attachNetStream(_ns);				_playbackTimer.reset();				_playbackTimer.start();				return true;			}			return false;					}		public function close():void {			if(_ns)			{				_ns.close();			}			if(_player)	_player.clear();			if(_nc)		_nc.close();		}		public function resume():void {			_isPaused = false;			_ns.resume();			_playbackTimer.start();			dispatchEvent( new Event( PLAY ) );		}		public function playPause():void {			if( _isPaused ) {				resume();			} else {					pause();			}		}		public function pause():void {			_isPaused = true;			if(_ns) _ns.pause();			dispatchEvent( new Event(PAUSE) );		}				public function stop():void{			rewind();			pause();			close();		}		public function rewind():void {			seek(0);		}		public function get time() : Number {			return _ns ? _ns.time : 0;		}		public function seek( pos:Number ) : void {			// pos = normalized target position (from 0.0 to 1.0)			if( _ns )			{				if( pos < getLoadProgress() )				{					_seekTarget = pos;					_isSeeking = true;					pos *=  _duration;					pos = Math.max( pos, 0 );					pos = Math.min( pos, _duration );					try					{						_ns.seek( pos );					} catch( err:Error )					{	//Should catch invalidSeekTime errors						trace("SimpleVideo::seek()",  err );					}				}			}		}				public function skip( amt:Number ):void		{	//skip forward/back			var pos:Number = progress + amt;			pos = pos % 1.0;	//wrap around to zero			seek(pos);		}				public function get isStreaming():Boolean{			return _server != null;		}		public function get progress() : Number {			//normalized position of where we are in the stream			if( _duration != 0 && _ns ) return _ns.time/duration;			else return 0;		}				public function get targetPosition():Number{			//accounts for seeking, only necessary for streaming video			if( _isSeeking )			{				return _seekTarget;			} else			{				return progress;			}		}				public function complete():Boolean		{			if( _duration != 0 )			{				return _ns.time >= duration - END_TIME_TOLERANCE;			}			return false;		}		public function setSize( w:Number, h:Number ) : void {			_player.width = w;			_player.height = h;		}		public function setVolume( level:Number ) : void {			var t:SoundTransform = _ns.soundTransform;			t.volume = level*level;			_ns.soundTransform = t;			_pVolume = level;		}		public function getVolume() : Number {			return _ns.soundTransform.volume;		}		public function mute() : void {			var t:SoundTransform = _ns.soundTransform;			var tempVolume:Number = ( t.volume == 0 ) ? _pVolume : 0;			_pVolume = t.volume;			t.volume = tempVolume;			_ns.soundTransform = t;		}				private function nsIOErrorHandler( e:IOErrorEvent ):void		{			trace("SimpleVideo::nsIOErrorHandler()", e);		}		private function asyncErrorHandler(event:AsyncErrorEvent) : void {			trace("Netstream encountered an async error", event.text);		}		private function metaDataHandler(infoObject:Object):void {			//this is only reliably called for the url passed to the netstream			_ratio 			= infoObject.width/infoObject.height;			_duration 		= infoObject.duration;						resize( _w, _h );			dispatchEvent( new Event( META_DATA ) );		}		public function resize( w:Number, h:Number ):void {			Numbers.fitWithRatio( _player, new Rectangle(0,0,w,h), _ratio );					}		public function get duration() : Number { 			return _duration;		}				public function get bufferLength():Number{			return _ns.bufferLength;		}				public function getIsPaused() : Boolean { 			return _isPaused;		}				public function getLoadProgress() : Number { 			return _ns.bytesLoaded/_ns.bytesTotal; 		}				public function get streaming():Boolean{			return _server != null;		}	}}